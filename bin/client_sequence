#!/usr/bin/env ruby
#
# file: ./bin/client_sequence
#

require 'bundler/setup'
require_relative '../config/version'
require 'skn_utils'

module SknUtils
  # Present in the gem
  # CommandJSONGet,    CommandFORMGet,
  # CommandJSONPost,   CommandFORMPost,
  # CommandJSONPut,     ?? Put
  #                    CommandFORMDelete
  # CommandJSONDelete -- we define it here

  # #################################################
  # Augment the Utility with a Delete
  class CommandJSONPDelete
    def self.call(options)  # {full_url:,username:,userpass:,payload:,headers:}
      new(options)
    end

    def json?
      true
    end

    def uri
      @_uri
    end

    def request
      req = @_headers.nil? ? Net::HTTP::Delete.new(uri.request_uri) : Net::HTTP::Delete.new(uri.request_uri, @_headers)        # Generate HTTPRequest object
      req.basic_auth(@_username, @_userpass) if credentials?
      req.content_type = 'application/json'
      req.body = formatted_data
      req
    end

    private

    def initialize(opts={})
      @_username = opts[:username]
      @_userpass = opts[:userpass]
      @_headers  = opts[:headers]
      @_uri      = URI.parse( opts[:full_url])
      @_data     = opts[:payload]
    end

    def formatted_data
      @_data.respond_to?(:to_json) ? @_data.to_json : @_data
    end

    def credentials?
      !(@_username.nil? || @_userpass.nil?)
    end
  end
end

class CommonElements
  @@new_users = [
      {action: :register, username: "bmagent",    userpass: "bmagent pwd" },
      {action: :register, username: "bmproducer", userpass: "bmproducer pwd" },
      {action: :register, username: "bmartist",   userpass: "bmartist pwd" }
  ]
  @@existing_users = [
      {action: :authenticate, username: "emowner",    userpass: "emowner pwd" },
      {action: :authenticate, username: "emkeeper",   userpass: "emkeeper pwd" },
      {action: :authenticate, username: "emuser",     userpass: "emuser pwd" }
  ]

  attr_reader :base_host_url, :admin_jwt_header

  def self.call(work, opts={})
    new(opts).call(work)
  end

  def call(work)
    raise NotImplementedError.new("You should code this method in your subclass[es]!")
  end

# Returns formatted header
  def apply_authentication(result)
    if result.success
      { Authorization: "Bearer #{result.value["token"]}" }
    else
      {Authentication: ""}
    end
  end

# returns SknSuccess/SknFailure
  def execute_request(command)
    SknUtils::HttpProcessor.call(command)   # mis-spelling these params result in [SknFailure, SknFailure, ...] results
  rescue => ex
    $stderr.puts ex
    $stderr.puts "#{ex.message}; #{ex.backtrace.join("\n")}"
    SknFailure.(ex.class.name, "#{ex.message}; #{ex.backtrace[0]}")
  end

  def prepare_core_commands(jwt_header, money, repeats)
    users      = SknUtils::CommandJSONGet.call({ headers: admin_jwt_header, full_url: "#{base_host_url}/api/v1/admin" })
    view_cmd   = SknUtils::CommandJSONGet.call({ headers: jwt_header, full_url: "#{base_host_url}/api/v1/money" })
    add_cmd    = SknUtils::CommandJSONPost.call({headers: jwt_header, full_url: "#{base_host_url}/api/v1/money", payload: {amount: money} })
    delete_cmd = SknUtils::CommandJSONPDelete.call({headers: jwt_header, full_url: "#{base_host_url}/api/v1/money", payload: {amount: (money / 2)} })
    delete_all_cmd = SknUtils::CommandJSONPDelete.call({headers: jwt_header, full_url: "#{base_host_url}/api/v1/money", payload: {amount: (repeats * (money / 2))} })
    stats = SknUtils::CommandJSONGet.call({full_url: "#{base_host_url}/status"})

    {core: [view_cmd,add_cmd,delete_cmd], cleanup: [delete_all_cmd, view_cmd, users, stats]}
  end

  def process(auth, repeats, money, unregister=nil, unreg_cmd=nil)
    results = []
    jwt_header = apply_authentication(auth)
    work_plans = prepare_core_commands(jwt_header, money, repeats)

    results = [auth]
    if unregister.present?
      work_plans[:cleanup].insert(-3, unreg_cmd)
      results.unshift(unregister)
    end

    repeats.times do
      results.push(
          work_plans[:core].collect do |cmd|
            execute_request(cmd)
          end
      )
    end
    results.push(
      work_plans[:cleanup].collect do |cmd|
          execute_request(cmd)
      end
    )
    results
  end

  def list_of_users
    (existing_users + new_users).flatten
  end

  def self.existing_users
    @@existing_users
  end
  def existing_users
    singleton_class.existing_users
  end

  def self.new_users
    @@new_users
  end
  def new_users
    singleton_class.new_users
  end

  def initialize(opts={})
    @opts = opts
    @base_host_url = opts.fetch(:base_host_url, "http://localhost:8585")
    username = opts.fetch(:username, "emadmin")
    password = opts.fetch(:password, "emadmin pwd")

    cmd = SknUtils::CommandJSONPost.call({username: username, userpass: password, full_url: "#{base_host_url}/authenticate"})
    @admin_jwt_header = apply_authentication( execute_request(cmd) )
  end
end

class WorkflowProcessor < CommonElements
  ##
  # register (if action: :register)
  # authenticate
  # -- extract jwt
  # repeat x
  #   view money
  #   add  money
  #   delete 1/2 money last added
  # delete balance (repeat * (money /2)
  # unregister
  #         header     repeats                footer = repeats + 1
  # return [*reg,auth, [view,add,del][][]..., [delete_all,view,users,*unreg,stats]
  #
  # {users: [{action: :authenticate, username: "emowner",    userpass: "emowner pwd" },...], repeats: 1, money: 100}
  def call(opts)
    action  = opts.fetch(:action, :register) # :authenticate
    money   = opts.fetch(:money, 500)
    repeats = opts.fetch(:repeats, 2)
    users   = opts.fetch(:users, list_of_users)
    repeats = 2 if repeats < 1

    if  opts[:users].nil? || opts[:users].empty?
      users = existing_users if action.to_s.eql?("authenticate")
      users = new_users      if action.to_s.eql?("register")
      users = list_of_users  if action.to_s.eql?("all")
    end


    SknSuccess.(
      users.collect do |work|
        workflow(work[:action], work[:username], work[:userpass], repeats, money)
      end
    )
  rescue => ex
    $stderr.puts ex
    SknFailure.(ex.class.name, "#{ex.message}; #{ex.backtrace.first.split("/").last}")
  end

  def workflow(action, username, password, repeats=20, money=500)
    reg_cmd = nil
    reg = nil
    unreg = nil
    if action.to_s.eql?("register")
      reg_cmd = SknUtils::CommandJSONPost.call({username: username, userpass: password, full_url: "#{base_host_url}/register"})
      reg = execute_request(reg_cmd)
        return reg unless reg.success
      unreg = SknUtils::CommandJSONPost.call({username: username, userpass: password, full_url: "#{base_host_url}/unregister" })
    end

    auth_cmd = SknUtils::CommandJSONPost.call({username: username, userpass: password, full_url: "#{base_host_url}/authenticate"})
    aut = execute_request(auth_cmd)
    return aut unless aut.success

    process(aut, repeats, money, reg, unreg)
  end
end

# formats this
#
#                 Workflow Metrics: SknSuccess, Metrics:
#                 ---[ METRICS ]--- Duration: 0.215 seconds
#                      ipl_timestamp: 020-05-28 23:14:17.3397                      timestamp: 020-05-28 23:17:55.6852                                    app_version: 2.1.0
#                 active_environment: development                                api_version: v1                                                        admin_events: 12
#                      registrations: 12                                        reg_failures: 0                                                          unregisters: 0
#                     unreg_failures: 0                                      authentications: 24                                                       auth_failures: 0
#                 not_found_failures: 12                                account_transactions: 65                                             credential_transactions: 13
#            api_view_money_requests: 72                              api_add_money_requests: 48                                           api_remove_money_requests: 72
#                uncaught_exceptions: 0                                    jwt_tokens_issued: 24                                                        jwt_audience: ["InternalUseOnly"]
#                credentials_storage: 685                                   accounts_storage: 345
def metric_formatter(skn, timestamp)
  return "Metrics not available! #{skn.message}" unless skn.success
  buffer = "\n\t\t---[ METRICS ]--- Duration: #{timestamp}\n"
  per_line = 0
  skn.value["metrics"].each_pair do |k,v|
    val = v
    if v.to_s.match(/[:|-]/)
      val = v.to_s[1..-12]
    end
    per_line += 1
    if ((per_line % 3) == 0)
      buffer += "\t\t\t#{k.to_s.rjust(26)}: #{val.to_s.ljust(18)}\n"
    else
      buffer += "\t#{k.to_s.rjust(26)}: #{val.to_s.ljust(20)}"
    end
  end
  buffer
end

def users_formatter(skn)
  return "Users not available! #{skn.message}" unless skn.success
  buffer = "\n\t\t---[ USERS ]---\n"
  per_line = 0
  skn.value["users"].each do |user|
    scopes = "none"
    scopes = user["scopes"].join(",").ljust(35) unless  user["scopes"].nil?
    per_line += 1
    if ((per_line % 3) == 0)
      buffer += "\t\t#{user["username"].to_s.rjust(20)}: #{scopes}\n"
    else
      buffer += "\t#{user["username"].to_s.rjust(20)}: #{scopes}"
    end
  end
  buffer += "\n"
end

# Result Structure
# two top level jobs existing and new users
#  [ SknSuccess.value(
#     [         -- repeats                       -- cleanups
#       [token,[view_cmd,add_cmd,delete_cmd]...,[delete_all_cmd, view_cmd, stats]],... for each existing user (3)
#     ]
#   ),
#   SknSuccess.value(
#     [             -- repeats                       -- cleanups
#       [reg,token,[view_cmd,add_cmd,delete_cmd]...,[delete_all_cmd, view_cmd, unreg, stats]],... for each user (3)
#     ]
#   )
# ]
# where repeats are: [view_cmd,add_cmd,delete_cmd] ;one for each count of repeats
# where cleanups are: [delete_all_cmd, view_cmd, stats] or [delete_all_cmd, view_cmd, unreg, stats] ; one per user
# each entry is either a SknSuccess or SknFailure object
def result_formatter(results, timestamp, repeats)
  footer = repeats + 1
  puts "Top Level Job: #{results.class.name}, Status: #{results.success?}, Message: #{results.messages}, Repeats: #{repeats},  Duration: #{timestamp},  Contains: #{results.values.count} work units"
  results.values.each do |trans|
    puts "\tWork Unit: #{trans.class.name}, Message: #{trans.message}, Contains: #{trans.value.count} elements"
    trans.value.each_with_index do |ele, unit|
      ele.each_with_index do |element, rep|
        rps = rep - 1
        if element.is_a?(Array)
          element.each_with_index do |wu,idx|
            if (wu.value.respond_to?(:keys) ? (wu.value.keys.include?('metrics') ? true : false) : false)
              metrics = metric_formatter(wu, timestamp)
              puts "\t\tWorkflow Metrics: #{wu.class.name}, Metrics: #{metrics}\n\n"
            elsif (wu.value.respond_to?(:keys) ? (wu.value.keys.include?('users') ? true : false) : false)
              users = users_formatter(wu)
                puts "\t\tWorkflow Users: #{wu.class.name}, Users: #{users}\n"
            elsif rps == footer
              puts "\t\tWorkflow Footer: #{wu.class.name}, Message: #{wu.message}, Contains: #{wu.value}"
            else
              puts "\t\t\t#{"%04d" % rps}:#{"%03d" % idx}~> Workflow Element: #{wu.class.name}, Message: #{wu.message}, Contains: #{wu.value}"
            end
          end
        else
          if element.value["token"]
            puts "\t\t#{"%04d" % unit} Workflow Authorization: #{element.class.name}, Contains: #{element.value.respond_to?(:keys) ? element.value.keys : element.value}"
          elsif element.value["message"]
            puts "\n\t\t#{"%04d" % unit} Workflow Register: #{element.class.name}, Contains: #{element.value}"
          else
            puts "\t\tWorkflow Cleanup: #{element.class.name}, Message: #{element.message}, Contains: #{element.value.respond_to?(:keys) ? element.value.keys : element.value} elements"
          end
        end
      end
    end
  end
  true
end

def run_with_callables(repeats = 1)

  commands =[
      ->(repeats){WorkflowProcessor.({action: :authenticate, users: [], repeats: repeats, money: 100})},
      ->(repeats){WorkflowProcessor.({action: :register, users: [], repeats: repeats, money: 100})}
  ]

  # Initialize the queue with Async Workers by default
  provider = SknUtils::ConcurrentJobs.call(async: true)

  #
  # The provided workers think the command are params to an executable
  # - in this case, our commands are executable
  #   so we need use this proc to reverse things
  job = ->(cmd){ cmd.call(repeats) }

  # Populate WorkQueue
  commands.each do |command|
    provider.register_job do
      begin
        job.call(command)
      rescue => ex
        $stderr.puts ex
        SknFailure.(ex.class.name, "#{ex.message}; #{ex.backtrace[0]}")
      end
    end
  end

  # Execute WorkQueue
  result = provider.render_jobs

  result_formatter result, provider.elapsed_time_string, repeats
rescue => e
  $stderr.puts e.message, e.backtrace
end

def run_with_params(repeats = 1)

  commands =[
      {action: :authenticate, users: CommonElements.existing_users , repeats: repeats, money: 100},
      {action: :register, users: CommonElements.new_users , repeats: repeats, money: 100}
  ]

  # Initialize the queue with Async Workers by default
  provider = SknUtils::ConcurrentJobs.call(async: true)

  # Populate WorkQueue
  provider.register_jobs(commands, WorkflowProcessor)

  # Execute WorkQueue
  result = provider.render_jobs

  result_formatter result, provider.elapsed_time_string, repeats
rescue => e
  $stderr.puts e.message, e.backtrace
end

# ##
# MainLine
# ##
#
begin
  repeats = (ARGV[0] || "10").to_i

  run_with_callables(repeats)
  run_with_params(repeats)

rescue => e
  $stderr.puts("Please ensure the Application is Started on Port: 8585.  Error: #{e.class.name}, Msg: #{e.message}")
end